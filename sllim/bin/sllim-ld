#!/bin/sh

# This script should work on systems with shells other than Bash (Dash, Busybox
# Ash, etc.) and with optional programs missing (such as "which").

set -eu

log() {
  # SLLIM_TTY may be set by sllim-env.
  if [ -n "${SLLIM_TTY+set}" ]; then
    echo "$@" >> "$SLLIM_TTY"
  else
    echo "$@" >&2
  fi
}

# Recursive executions should never happen, but we check just in case.
if [ -n "${SLLIM_IN_LD+set}" ]; then
  log error: sllim-ld called recursively: "$0" "$@"
  exit 1
fi
export SLLIM_IN_LD=1

# Create temporary directory.
SLLIM_TMP="$(mktemp -t -d sllim-ld.XXXXXXXXXX)"

# Commented because we want to leave temporary files around in case of error.
#trap 'rm -rf "$SLLIM_TMP"' EXIT

ORIG_ARGS=""
set -- "$@" --sllim-divider
while true; do
  if [ "$1" = "--sllim-divider" ]; then
    # Done processing all options.
    shift
    break
  fi

  ORIG_ARGS="${ORIG_ARGS:+$ORIG_ARGS }'$1'"

  # Find the output file name.
  # NOTE: this could work incorrectly if an argument to some other option
  # starts with "-o" or "--output=". To fix that, we would need to parse every
  # option that has an argument (see llvm/lld/ELF/Options.td).
  case "$1" in
    -v|--version)
      NO_LINK=1
      ;;

    -o|--output)
      ORIG_ARGS="${ORIG_ARGS:+$ORIG_ARGS }'$2'"
      ORIG_OUTPUT="$2"
      set -- "$@" "$1" "$2"
      shift 2
      continue
      ;;

    -o?*)
      ORIG_OUTPUT="${1#-o}"
      ;;

    --output=?*)
      ORIG_OUTPUT="${1#--output=}"
      ;;

    *)
      ;;
  esac

  set -- "$@" "$1"
  shift
done

LD="${SLLIM_LD-ld}"

rm -f "$SLLIM_TMP/linker-output"

try_command() {
  MESSAGE="$1"
  shift
  RC=0
  "$@" || RC=$?
  if [ "$RC" -ne 0 ]; then
    log error: sllim-ld: "$MESSAGE" failed
  fi
  return "$RC"
}

perform_link() {
  if [ -z "${NO_LINK+set}" ]; then
    # --gc-sections would delete the .llvmbc section.
    # Output to a temporary file, to make sure we process it properly.
    try_command "initial link" "$LD" \
      "$@" \
      --no-gc-sections \
      -o "$SLLIM_TMP/linker-output"
  else
    try_command "initial link" "$LD" "$@"
  fi

  if [ -n "${NO_LINK+set}" ]; then
    return 0
  fi

  log
  log sllim-ld: optimizing "$ORIG_OUTPUT"
  log

  if [ ! -f "$SLLIM_TMP/linker-output" ]; then
    log error: sllim-ld: missing output file "$SLLIM_TMP/linker-output"
    return 1
  fi

  try_command "bitcode extraction" \
    "${SLLIM_BC_IMITATE-bc-imitate}" extract \
    -o "$SLLIM_TMP/input.bc" \
    -- "$SLLIM_TMP/linker-output"

  try_command "sllim" \
    "${SLLIM-sllim}" \
    -o "$SLLIM_TMP/optimized.o" \
    -- "$SLLIM_TMP/input.bc"

  # Prepend our optimized object file to the link command, so it overrides the
  # original object files.
  #
  # TODO: remove the original object files (at least, the ones that contain
  # bitcode) from the arguments, so we don't link in multiple copies of the
  # same code, and we don't have to force -z muldefs and --gc-sections to get
  # rid of the extra copies.
  try_command "final link" \
    "$LD" \
    "$SLLIM_TMP/optimized.o" \
    "$@" \
    -z muldefs \
    --gc-sections
}

RC=0
perform_link "$@" || RC=$?
if [ "$RC" -ne 0 ]; then
  log error: sllim-ld error
  log Original command line: "$0" "$ORIG_ARGS"
  log Modified command line: "$LD" "$@"
  exit "$RC"
fi

rm -rf "$SLLIM_TMP"
