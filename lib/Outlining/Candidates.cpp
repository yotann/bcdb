#include "Outlining/Candidates.h"

#include <llvm/IR/InstrTypes.h>
#include <llvm/InitializePasses.h>
#include <llvm/Support/CommandLine.h>
#include <llvm/Support/FormatVariadic.h>

#include "bcdb/LLVMCompat.h"

using namespace bcdb;
using namespace llvm;

static cl::list<int> OutlineOnly("outline-only", cl::CommaSeparated,
                                 cl::ZeroOrMore,
                                 cl::desc("Specify nodes to outline"),
                                 cl::value_desc("node,node,..."));

static cl::opt<size_t>
    OutlineMaxAdjacent("outline-max-adjacent", cl::init(10),
                       cl::desc("Maximum number of unrelated adjacent "
                                "instructions to outline together."));

static cl::opt<size_t>
    OutlineMaxNodes("outline-max-nodes", cl::init(50),
                    cl::desc("Maximum number of instructions to outline."));

static cl::opt<bool> OutlineUnprofitable(
    "outline-unprofitable",
    cl::desc(
        "Outline every possible sequence, even if it seems unprofitable."));

OutliningCandidates::OutliningCandidates(Function &F,
                                         OutliningDependenceResults &OutDep)
    : F(F), OutDep(OutDep) {
  if (!OutlineOnly.empty()) {
    SparseBitVector<> BV;
    for (int i : OutlineOnly)
      BV.set(i);
    if (!OutDep.isOutlinable(BV))
      report_fatal_error("Specified nodes cannot be outlined",
                         /* gen_crash_diag */ false);
    Candidates.push_back(std::move(BV));
    return;
  }

  for (BasicBlock &block : F) {
    if (!OutDep.NodeIndices.count(&block))
      continue; // unreachable
    auto first = OutDep.NodeIndices[block.getFirstNonPHI()];
    auto last = OutDep.NodeIndices[block.getTerminator()];

    // Don't bother outlining unconditional branches, unless part of a loop.
    if (block.getTerminator()->getOpcode() == Instruction::Br &&
        block.getSingleSuccessor() &&
        OutDep.DT.dominates(&block, block.getSingleSuccessor()))
      last--;

    for (auto i = first; i < last; ++i) {
      generateCandidatesEndingAt(i);
    }
  }
}

void OutliningCandidates::generateCandidatesEndingAt(size_t i) {
  // bv is the current candidate. deps is the union of all DominatingDepends of
  // nodes in bv, minus things that are already in bv.
  SparseBitVector<> bv, deps;
  bv.set(i);
  bv |= OutDep.ForcedDepends[i];
  for (auto j : bv)
    deps |= OutDep.DominatingDepends[j];
  deps.intersectWithComplement(bv);

  while (bv.count() <= OutlineMaxNodes && !OutDep.PreventsOutlining.intersects(bv)) {
    emitCandidate(bv);

    // Generate the next candidate.
    // TODO: skip over:
    // - Candidates where dom is a block header, but we don't include any
    //   control flow that leads to it.
    // - Candidates where there is a single terminator consisting of an
    //   unconditional branch, not part of a loop.
    // - Other boring candidates.

    // Find the next node to add.
    int dom = bv.find_first();
    assert(dom >= 0);
    int next_dep = deps.find_last();
    if (next_dep < 0)
      break; // There are no more candidates.
    assert(next_dep < dom);
    if (!OutDep.Dominators[dom].test(next_dep))
      report_fatal_error("is this possible?");

    // Add the node and its dependences.
    assert(bv.test_and_set(next_dep));
    deps |= OutDep.DominatingDepends[next_dep];
    bool redundant = false;
    for (auto j : OutDep.ForcedDepends[next_dep]) {
      if (j == i) {
        // This candidate, and all further candidates starting from node i,
        // have already been generated by generateCandidatesEndingAt(next_dep).
        // TODO: does this detect all duplicates, or only a subset?
        redundant = true;
        break;
      }
      if (bv.test_and_set(j))
        deps |= OutDep.DominatingDepends[j];
    }
    if (redundant)
      break;

    // Forced depends may cause the outlining point to move before
    // next_dep, in which case we need to add any dominating depends that
    // lie between the outlining point and next_dep.
    deps.intersectWithComplement(bv);
    int new_op = bv.find_first();
    while (true) {
      int j = deps.find_last();
      if (j < new_op)
        break;
      bv.set(j);
      deps.reset(j);
    }
  }

  // Generate contiguous sequences ending at node i. We do this in case there
  // are sequences of related instructions (for example, initializing different
  // fields of a struct) that are not linked by dependences, so no candidates
  // will have been generated above.
  //
  // TODO: can we be smarter about this? For instance, we could only use
  // instructions that share at least one operand.
  SparseBitVector<> contig_bv;
  // Stop after OutlineMaxAdjacent nodes, or at the beginning of the block.
  int first_contig =
      static_cast<int>(i) + 1 - static_cast<int>(OutlineMaxAdjacent);
  first_contig = std::max(
      first_contig,
      static_cast<int>(OutDep.NodeIndices[cast<Instruction>(OutDep.Nodes[i])->getParent()->getFirstNonPHI()]));
  bool already_in_bv = true; // Skip sequences that already belong to bv.
  for (int j = i; j >= first_contig; j--) {
    contig_bv.set(j);
    if (OutDep.PreventsOutlining.test(j))
      break;
    if (!contig_bv.contains(OutDep.ForcedDepends[j]))
      break;
    if (already_in_bv && bv.test(j))
      continue;
    already_in_bv = false;
    emitCandidate(contig_bv);
  }
}

void OutliningCandidates::emitCandidate(const SparseBitVector<> &bv) {
  if (!OutDep.isOutlinable(bv)) {
    OutDep.printSet(errs(), bv);
    report_fatal_error("invalid outlining candidate");
  }
  // FIXME: check profitability, and limit number of args/return values.
  Candidates.emplace_back(bv);
}

void OutliningCandidates::print(raw_ostream &OS) const {
  for (const SparseBitVector<> &BV : Candidates) {
    OS << "candidate: [";
    OutDep.printSet(OS, BV);
    OS << "]\n";
  }
}

OutliningCandidatesWrapperPass::OutliningCandidatesWrapperPass()
    : FunctionPass(ID) {}

bool OutliningCandidatesWrapperPass::runOnFunction(Function &F) {
  auto &OutDep = getAnalysis<OutliningDependenceWrapperPass>().getOutDep();
  OutCands.emplace(F, OutDep);
  return false;
}

void OutliningCandidatesWrapperPass::print(raw_ostream &OS,
                                           const Module *M) const {
  OutCands->print(OS);
}

void OutliningCandidatesWrapperPass::getAnalysisUsage(AnalysisUsage &AU) const {
  AU.setPreservesAll();
  AU.addRequiredTransitive<OutliningDependenceWrapperPass>();
}

void OutliningCandidatesWrapperPass::releaseMemory() { OutCands.reset(); }

void OutliningCandidatesWrapperPass::verifyAnalysis() const {
  assert(false && "unimplemented");
}

char OutliningCandidatesWrapperPass::ID = 0;
namespace {
struct RegisterPassX : RegisterPass<OutliningCandidatesWrapperPass> {
  RegisterPassX()
      : RegisterPass("outlining-candidates",
                     "Outlining Candidates Analysis Pass", false, true) {
    // Ensure required passes are loaded, even if this pass used in a program
    // that doesn't load all the standard LLVM passes.
    initializeDominatorTreeWrapperPassPass(*PassRegistry::getPassRegistry());
    initializePostDominatorTreeWrapperPassPass(
        *PassRegistry::getPassRegistry());
    initializeMemorySSAWrapperPassPass(*PassRegistry::getPassRegistry());
  }
};
} // end anonymous namespace
static RegisterPassX X;
